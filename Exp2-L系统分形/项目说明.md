# 项目 2: 确定性迭代 II - L-System 生成分形 (曲线与树)

### 目标

掌握 L-系统 (Lindenmayer System) 的基本原理，包括符号重写规则和状态栈机制 (`[]`)。运用 L-System 生成并绘制经典的曲线分形（科赫曲线）和具有分支结构的分形（分形树）。

### 背景

L-系统是一种并行重写系统和形式语法。它通过以下组件定义复杂结构：

1.  **字母表 (Alphabet):** 可以出现在字符串中的符号集合。
2.  **公理 (Axiom):** 定义初始状态的起始字符串。
3.  **产生式规则 (Production Rules):** 定义如何将字母表中的符号替换为其他符号序列的规则。
4.  **解释机制:** 将最终生成的符号串转换为几何图形的规则。

**常用解释符号:**

*   `F`: 向前移动一个步长 `step`，并绘制线段。
*   `f`: 向前移动一个步长 `step`，但不绘制线段。
*   `+`: 左转 `angle` 度。
*   `-`: 右转 `angle` 度。
*   `[`: **压栈 (Push)**。保存当前的绘图状态（位置和方向）到栈中。用于开始一个分支。
*   `]`: **出栈 (Pop)**。恢复到栈顶保存的状态（位置和方向），但不绘制连线。用于结束一个分支，返回到分支点。

**本次项目涉及的分形:**

*   **科赫曲线 (Koch Curve):**
    *   公理 (Axiom): `F`
    *   规则 (Rules): `F → F+F--F+F`
    *   角度 (Angle): 60°
*   **分形二叉树 (Fractal Binary Tree):** (一个常见变种)
    *   公理 (Axiom): `X` (或者用 `0` 或 `1` 开始，规则相应调整)
    *   规则 (Rules): `X → F+[[X]-X]-F[-FX]+X`, `F → FF` (这里的 `X` 是非绘制符, `F` 是绘制符)
    *   *或者使用题目最初提到的规则：*
    *   公理 (Axiom): `0`
    *   规则 (Rules): `1 → 11`, `0 → 1[0]0`
    *   角度 (Angle): 45° (或其他自选角度)
    *   *解释:* `0` 和 `1` 都表示向前绘制一个枝干。`[` 表示保存状态并左转，`]` 表示恢复状态并右转（这种解释需要自定义绘图逻辑）。 **我们将主要基于这种规则实现。**

### 任务

1.  **实现 L-System 字符串生成器:**
    *   创建一个函数 `apply_rules(axiom, rules, iterations)`。
    *   输入：初始字符串 `axiom`，一个包含重写规则的字典 `rules` (例如 `{'F': 'F+F--F+F'}` 或 `{'0': '1[0]0', '1': '11'}`），以及迭代次数 `iterations`。
    *   输出：经过指定次数迭代后生成的最终符号串。
2.  **实现 L-System 绘图器 (`matplotlib`):**
    *   创建一个函数 `draw_l_system(commands, angle_deg, step, initial_pos=(0, 0), initial_angle=90)`。
    *   输入：L-System 生成的指令字符串 `commands`，每次转向的角度 `angle_deg`，每步绘制的长度 `step`，初始位置 `initial_pos`，初始方向 `initial_angle` (例如 90 度表示向上)。
    *   内部逻辑：
        *   维护当前状态：位置 `(x, y)` 和方向 `current_angle` (以度或弧度表示)。
        *   初始化一个空栈 `stack` 用于存储状态 `(x, y, current_angle)`。
        *   获取当前的 `matplotlib` 绘图轴 (`ax = plt.gca()`)。
        *   遍历 `commands` 字符串中的每个字符：
            *   如果字符是 `F`（或 `0`, `1` 对于树的规则）：计算基于当前位置、方向和 `step` 的下一个点 `(nx, ny)`。使用 `ax.plot([x, nx], [y, ny], ...)` 绘制线段。更新当前位置为 `(nx, ny)`。
            *   如果字符是 `+`: 增加 `current_angle` (例如 `current_angle += angle_deg`)。
            *   如果字符是 `-`: 减少 `current_angle` (例如 `current_angle -= angle_deg`)。
            *   如果字符是 `[`: 将当前状态 `(x, y, current_angle)` 压入 `stack`。**根据树规则的解释，可能还需要在这里应用转向，例如左转。** (我们将遵循 `0 → 1[0]0` 规则的解释：`[` 保存&左转, `]` 恢复&右转)
            *   如果字符是 `]`: 从 `stack` 弹出状态，并恢复 `x, y, current_angle`。**根据树规则的解释，可能还需要在这里应用转向，例如右转。**
3.  **主程序:**
    *   为科赫曲线和分形树分别定义公理、规则、角度、迭代次数和步长。
    *   调用 `apply_rules` 生成指令字符串。
    *   创建 `matplotlib` 图形和轴。
    *   调用 `draw_l_system` 绘制分形。
    *   设置图形标题、坐标轴（建议 `axis('equal')` 和 `axis('off')`）。
    *   保存图像文件。

### 挑战与思考

*   L-System 方法与项目 1 的几何迭代方法在概念和实现上有何不同？哪种更适合生成哪类分形？
*   尝试修改分形树的规则、角度或迭代次数，观察生成形态的变化。
*   如何为分形树引入随机性（例如，随机改变一点角度或步长）使其看起来更自然？

### 提交

*   `L_system.py`: 包含 L-System 字符串生成、绘图函数以及生成科赫曲线和分形树的完整代码。
*    L-System 生成的科赫曲线图像。
*    L-System 生成的分形树图像。

