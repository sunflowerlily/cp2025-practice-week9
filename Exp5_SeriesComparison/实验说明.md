# 实验五：不同形式级数求和的数值稳定性比较

## 实验背景

在数学推导中，我们经常会遇到形式不同但结果相同的表达式。例如，考虑以下三个相关的级数求和：

$$ \begin{align} S_N^{(1)} &= \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} \\ S_N^{(2)} &= -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} \\ S_N^{(3)} &= \sum_{n=1}^{N} \frac{1}{2n(2n+1)} \end{align} $$

可以通过简单的代数推导证明，这三个和在数学上是严格相等的（对于任意有限的 $N \ge 1$）。例如，可以将 $S_N^{(1)}$ 的项两两配对：

$$ S_N^{(1)} = \sum_{k=1}^{N} \left[ (-1)^{2k-1} \frac{2k-1}{2k} + (-1)^{2k} \frac{2k}{2k+1} \right] = \sum_{k=1}^{N} \left[ -\frac{2k-1}{2k} + \frac{2k}{2k+1} \right] $$

这表明 $S_N^{(1)}$ 实际上等于 $S_N^{(2)}$。进一步，通分括号内的项：

$$ -\frac{2k-1}{2k} + \frac{2k}{2k+1} = \frac{-(2k-1)(2k+1) + (2k)^2}{2k(2k+1)} = \frac{-(4k^2-1) + 4k^2}{2k(2k+1)} = \frac{1}{2k(2k+1)} $$

这表明 $S_N^{(1)}$ 和 $S_N^{(2)}$ 都等于 $S_N^{(3)}$。

然而，“数学上相等”并不意味着“数值计算结果相同”。由于计算机使用有限精度浮点数，不同的计算路径可能积累不同大小和类型的误差。特别是 $S_N^{(2)}$，它涉及两个分别求和然后相减的过程。如果这两个和都很大且非常接近，它们的相减可能会导致**灾难性抵消 (Catastrophic Cancellation)**，使得结果的有效数字大量丢失，相对误差急剧增大。

本实验旨在通过计算和比较这三个级数，直观地展示不同计算形式对数值精度的巨大影响。我们将 $S_N^{(3)}$（由小的正项组成，通常最稳定）视为“精确解”的参考。

## 实验目标

1.  **实现三个级数的计算：** 编写代码分别计算 $S_N^{(1)}, S_N^{(2)}, S_N^{(3)}$。
2.  **比较数值结果：** 观察并量化三种方法在有限精度计算下的结果差异。
3.  **分析误差来源：** 理解为什么 $S_N^{(2)}$ 的数值计算特别不稳定，与灾难性抵消联系起来。
4.  **可视化误差行为：** 绘制误差随 $N$ 变化的图像，分析误差增长趋势。
5.  **实践性能工具 (可选)：** 使用 `time` 模块和 `numba.jit`。

## 实验任务

1. **实现求和函数：**
   * 在 `series_sum.py` 文件中，完成 `sum_S1(N)` 函数。
   * 完成 `sum_S2(N)` 函数。注意：需要分别计算两个内部和，然后相减。
   * 完成 `sum_S3(N)` 函数。

2. **计算相对误差：**
   * 选择 $S_N^{(3)}$ 作为参考"精确值"。
   * 对于一系列 $N$ 值（例如，从 1 到 10000，建议在对数尺度上取点，如 `np.logspace(0, 4, 50)`），计算三个级数。
   * 计算 $S_N^{(1)}$ 相对于 $S_N^{(3)}$ 的相对误差: $\text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $。
   * 计算 $S_N^{(2)}$ 相对于 $S_N^{(3)}$ 的相对误差: $\text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $。

3. **绘制 Log-Log 图：**
   * 绘制相对误差 $\text{Err}_1$ 和 $\text{Err}_2$ 关于 $N$ 的关系图，使用双对数坐标轴。
   * 在同一张图上绘制两条误差曲线，并添加适当的标签和图例。

4.  **分析与解释：**
    *   比较 $S_N^{(1)}$ 和 $S_N^{(2)}$ 的误差曲线。哪种求和方式误差更小？哪种误差增长更快？
    *   重点解释为什么 $S_N^{(2)}$ 的误差通常远大于 $S_N^{(1)}$ 和 $S_N^{(3)}$ 的计算精度极限。将其与灾难性抵消联系起来：解释 $-\sum\limits_{n=1}^{N}\frac{2n-1}{2n}$ 和 $\sum\limits_{n=1}^{N}\frac{2n}{2n+1}$ 这两个内部和的值如何随 $N$ 变化，以及它们相减时发生了什么。
    *   观察误差曲线在双对数图上的形状。是否存在近似的直线部分？如果是，说明误差 $E$ 与 $N$ 的某个幂次 $p$ 成正比 ($E \propto N^p$)。估算这个 $p$ 值（即直线的斜率），特别是对于 $S_N^{(2)}$ 的误差。

5.  **性能考量 (可选/练习)：**
    *   测量计算三个和对于一个较大的 $N$ (例如 $N=10^5$ 或 $10^6$) 所需的时间。
    *   尝试使用 `@jit(nopython=True)` 装饰器加速函数，并比较性能。

## 代码模板

你需要在 `series_sum.py` 文件中完成 `sum_S1`, `sum_S2`, `sum_S3` 函数。该文件包含一个 `if __name__ == '__main__':` 块，用于执行计算、打印结果和生成图表。

## 提交要求

1. **代码：** 完成并提交 `series_sum.py` 文件。
2. **实验报告：** 提交一份 Markdown 格式的实验报告 (`实验报告.md`)，包含：
   * **方法简述：** 描述你实现的三个求和方法。
   * **结果图表：** 包含误差随 N 变化的双对数图。
   * **分析与讨论：**
     * 比较不同求和方式的误差大小和变化趋势。
     * 详细解释 $S_N^{(2)}$ 产生巨大误差的原因（灾难性抵消）。
     * 分析误差增长行为（是否与 $N^p$ 成正比，估算 $p$）。
   * **结论：** 总结数学等价性与数值稳定性之间的关系。

## 评分标准

* **代码实现 (40%)：**
  * `sum_S1`, `sum_S2`, `sum_S3` 函数正确实现 (各占约 13%)

* **数据分析与可视化 (30%)：**
  * 相对误差计算正确 (10%)
  * Log-log 图绘制正确、清晰，包含两条误差曲线、标签和图例 (20%)

* **实验报告 (30%)：**
  * 对灾难性抵消和 $S_N^{(2)}$ 误差来源的解释清晰、准确 (15%)
  * 误差趋势分析（包括幂律行为）到位 (10%)
  * 报告结构清晰，包含所有要求的部分 (5%)