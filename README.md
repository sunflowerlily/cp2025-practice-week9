# 计算物理实验第九周：分形探索

欢迎来到分形的世界！本系列作业包含五个编程项目，旨在引导你探索和实践生成各种迷人分形图案的不同方法。你将使用 Python 编程语言，结合几何迭代、L-系统、迭代函数系统 (IFS) 和复数动力学等技术，亲手创造出这些复杂的结构。

## 学习目标

完成本系列作业后，你将能够：

*   理解并区分几种主要的分形生成范式：确定性几何迭代、L-系统、概率性迭代函数系统 (IFS) 和复数动力学。
*   使用 Python 编程语言实现这些分形生成算法。
*   利用 `matplotlib` 库将生成的分形进行可视化。
*   体会简单规则如何通过迭代产生复杂的、具有自相似性的结构。
*   初步理解分形维数的概念，并能动手实现盒计数法来估算分形维数。
*   欣赏数学和计算在模拟自然形态和探索复杂系统中的力量。

## 作业概览

本次大作业包含以下五个独立的编程项目：

1.  **项目 1: 确定性迭代 I - 相似性变换生成曲线分形**
2.  **项目 2: 确定性迭代 II - L-System 生成分形 (曲线与树)**
3.  **项目 3: 随机迭代 - 概率性迭代函数系统 (IFS)**
4.  **项目 4: 复数动力学 - Mandelbrot 与 Julia 集**
5.  **项目 5: 分形分析 - 盒计数法估算分形维数**

请按顺序完成这些项目，后面的项目可能会用到前面项目建立的概念或技能。

## 通用指南

*   **编程语言:** 所有项目请使用 Python 3.x 完成。
*   **库:**
    *   项目 1 & 2: 推荐使用 `matplotlib.pyplot` 进行绘图，例如使用 `plot` 函数绘制线段。
    *   项目 3 & 4: 推荐使用 `matplotlib.pyplot` 进行点集的绘制 (`scatter`) 和图像显示 (`imshow`)。可能需要 `random` 库 (项目 3) 和 `cmath` 或 `numpy` (项目 4)。
    *   项目 5: 需要 `matplotlib` (用于绘图和可能的图像处理)，以及 `numpy` (用于数组操作和线性回归)。
    *   请确保安装了必要的库 (`pip install matplotlib numpy`)。
*   **代码风格:** 请编写清晰、结构良好、有适当注释的代码。使用有意义的变量名。
*   **提交:**
    *   通过 GitHub Classroom 接受作业邀请，这会为你创建一个私有仓库。
    *   将你的代码 (`.py` 文件) 和生成的图像 (`.png` 或 `.jpg` 文件) 添加到你的仓库中。
    *   对于每个项目，确保提交了所有要求的代码和结果文件。
    *   通过 `git commit` 和 `git push` 将你的工作提交到 GitHub 仓库。请确保在截止日期前完成最终提交。

---

## 项目详情

### 项目 1: 确定性迭代 I - 相似性变换生成曲线分形

*   **目标:** 掌握通过重复应用几何相似变换（生成元思想）来构造分形的方法。
*   **背景:** 从初始形状（如线段）开始，递归地将每个部分替换为按比例缩小、旋转和平移后的“生成元”副本。
*   **任务:**
    1.  实现一个递归函数（或等效的迭代方法），根据科赫曲线的生成元规则 (`_/\_`, 60度角) 迭代生成线段集合。你需要存储线段的起点和终点坐标。
    2.  实现一个类似的函数，根据闵可夫斯基香肠曲线的生成元规则 (`_|¯|_|¯|_`, 90度角) 迭代生成线段集合。
    3.  编写主程序，调用上述函数，并使用 `matplotlib.pyplot.plot` 绘制出最终迭代层级的所有线段，形成曲线图像（科赫建议 3-4 次，闵可夫斯基建议 2-3 次）。
*   **挑战/思考:** 对比 L-System 方法，思考此方法的优缺点。如何生成科赫雪花？
*   **提交:**
    *   `project1_koch_minkowski.py` (包含两个曲线的生成和绘图代码)
    *   `koch_curve.png` (生成的科赫曲线图像)
    *   `minkowski_sausage.png` (生成的闵可夫斯基香肠曲线图像)

### 项目 2: 确定性迭代 II - L-System 生成分形 (曲线与树)

*   **目标:** 掌握 L-系统原理，使用符号重写和状态栈 (`[]`) 生成曲线和分支结构。
*   **背景:** L-System 通过迭代更新符号串，然后解释符号串指令来绘图。`[` 保存状态（位置、方向），`]` 恢复状态，用于分支。
*   **任务:**
    1.  实现一个 L-System 字符串生成函数 `apply_rules(axiom, rules, iterations)`。
    2.  实现一个绘图函数 `draw_l_system`，该函数接收 L-System 生成的指令字符串、角度、步长等参数。你需要维护当前绘图点的位置和方向（角度）。
        *   对于 `F`：计算下一个点的位置，并使用 `matplotlib.pyplot.plot` 绘制从当前点到下一个点的线段，然后更新当前点位置。
        *   对于 `+`/`-`：更新当前方向（角度）。
        *   对于 `[`：将当前位置和方向压入一个栈 (stack)。
        *   对于 `]`：从栈中弹出位置和方向，恢复状态（注意：不绘制连线，只是移动“画笔”位置）。
    3.  使用 L-System 方法生成并绘制：
        *   科赫曲线 (公理="F", 规则=`F → F+F--F+F`, 角度=60°, 迭代 3-4 次)。
        *   分形二叉树 (公理="0", 规则=`1 → 11`, `0 → 1[0]0`, 角度=45° 或自选, 迭代 5-7 次)。注意符号解释：0/1 画枝, [ 保存&左转, ] 恢复&右转。
*   **挑战/思考:** 如何调整参数生成不同形态的树？如何引入随机性？
*   **提交:**
    *   `project2_l_system.py` (包含 L-System 实现和两个分形的生成绘图代码)
    *   `l_system_koch.png` (L-System 生成的科赫曲线)
    *   `fractal_tree.png` (L-System 生成的分形树)

### 项目 3: 随机迭代 - 概率性迭代函数系统 (IFS)

*   **目标:** 理解并实现基于概率选择仿射变换的 IFS 来生成分形。
*   **背景:** IFS 通过在一个点上反复随机应用一组带概率的收缩仿射变换生成点云，构成或逼近分形吸引子。初始点 `(x₀, y₀) = (0.5, 0)`。
*   **任务:**
    1.  实现一个函数，根据 IFS 参数（变换列表及概率），随机选择并应用一个仿射变换到当前点，返回新点。
    2.  编写主程序，从初始点 `(0.5, 0)` 开始，迭代数万次（例如 50,000 次），忽略最初的 100 个点，然后使用 `matplotlib.pyplot.scatter` 绘制后续生成的点。调整点的大小 (`s`) 和透明度 (`alpha`) 可能获得更好的视觉效果。
    3.  分别使用作业描述中给出的**巴恩斯利蕨 (Barnsley's Fern)** 和 **概率树 (Probability Tree)** 的 IFS 参数（仿射变换方程和概率）生成并绘制对应的分形图案。
*   **挑战/思考:** 分析各变换对蕨类形态的贡献。修改概率树参数观察影响。
*   **提交:**
    *   `project3_ifs.py` (包含 IFS 实现和两个分形的生成绘图代码)
    *   `barnsley_fern.png` (生成的巴恩斯利蕨图像)
    *   `probability_tree.png` (生成的概率树图像)

### 项目 4: 复数动力学 - Mandelbrot 与 Julia 集

*   **目标:** 通过迭代复变函数 `zₙ₊₁ = zₙ² + c` 探索 Mandelbrot 集和 Julia 集，理解稳定与混沌边界。
*   **背景:** Mandelbrot 集是参数 `c` 的集合；Julia 集是固定 `c` 时初始值 `z₀` 的集合。通常通过判断迭代是否在有限步内 `|zₙ| > 2` 来确定发散，用逃逸时间着色。
*   **任务:**
    1.  实现计算 Mandelbrot 集像素颜色（基于逃逸时间）的函数。
    2.  编写程序，生成一个二维数组表示复平面区域内各点的逃逸时间，然后使用 `matplotlib.pyplot.imshow` 将该数组可视化为 Mandelbrot 集图像。选择合适的色彩映射 (colormap)。
    3.  实现计算 Julia 集像素颜色（基于逃逸时间）的函数。
    4.  选择至少 3 个不同的复数 `c` 值（例如 `c = -0.8 + 0.156i`, `c = 0.285 + 0.01i`, `c = -0.4 + 0.6i`, `c = i` 等），生成对应的二维逃逸时间数组，并使用 `imshow` 绘制对应的 Julia 集图像。
*   **挑战/思考:** 比较不同 `c` 值对应的 Julia 集形态。尝试平滑着色。考虑 `zₙ₊₁ = zₙᵐ + c` (m>2) 的情况（可选）。
*   **提交:**
    *   `project4_mandelbrot_julia.py` (包含 Mandelbrot 和 Julia 集的生成绘图代码)
    *   `mandelbrot_set.png` (生成的 Mandelbrot 集图像)
    *   `julia_set_c1.png`, `julia_set_c2.png`, `julia_set_c3.png` (至少三个不同 c 值的 Julia 集图像)

### 项目 5: 分形分析 - 盒计数法估算分形维数

*   **目标:** 理解盒维数概念，并编程实现盒计数法来估算一个分形图像的维数。
*   **背景:** 盒维数 `D` 通过拟合 `log N(ε) ≈ -D log ε + const` 来估计，其中 `N(ε)` 是覆盖分形所需的边长为 `ε` 的盒子数量。
*   **任务:**
    1.  选择一个你之前生成的、结构清晰的分形图像（如科赫曲线、谢尔宾斯基三角（若实现）、或巴恩斯利蕨的点云图）。将其处理为二值图像（例如，使用 `matplotlib.image` 读取图像，然后进行阈值处理得到 `numpy` 数组）。
    2.  实现盒计数算法：对一系列盒子边长 `ε`（例如从图像尺寸的 1/2, 1/4... 到 1 像素），计算覆盖所有值为 1 (或非背景色) 的像素所需的盒子数 `N(ε)`。这通常通过在图像上叠加网格并计算包含前景像素的网格单元数来完成。
    3.  记录 `(log ε, log N(ε))` 数据点。
    4.  使用 `numpy.polyfit` 或类似方法进行线性回归，拟合 `log N(ε)` 对 `log ε` 的关系。
    5.  报告拟合得到的斜率的相反数，即为估算的盒维数 `D`。
*   **挑战/思考:** 将计算结果与理论维数比较，分析误差来源。对简单形状应用此方法验证。
*   **提交:**
    *   `project5_box_counting.py` (包含盒计数算法实现和维数计算)
    *   说明你使用了哪个分形图像进行分析（或直接在代码中加载/生成）。
    *   在代码输出或注释中清晰报告计算过程（例如 `ε` 和 `N(ε)` 的对应值）和最终估算的盒维数 `D`。
    *   （可选）`log_log_plot.png` (展示 `log N(ε)` vs `log ε` 的散点图和拟合直线)

---

## 评估

你的作业将基于以下方面进行评估：

*   **功能正确性:** 代码是否能成功生成所要求的分形图案？维数计算是否合理？
*   **算法实现:** 是否正确理解并实现了相应的分形生成算法或分析方法？
*   **代码质量:** 代码是否清晰、结构良好、有注释、易于理解？
*   **结果呈现:** 生成的图像是否清晰、符合预期？分析结果是否明确报告？
*   **完成度:** 是否完成了所有要求的任务和提交了所有必需的文件？

## 资源

*   Python 官方文档: [https://docs.python.org/3/](https://docs.python.org/3/)
*   `matplotlib` 官方文档: [https://matplotlib.org/stable/contents.html](https://matplotlib.org/stable/contents.html)
*   `numpy` 官方文档: [https://numpy.org/doc/stable/](https://numpy.org/doc/stable/)
*   维基百科等在线资源关于各种分形（Koch Curve, Mandelbrot Set, IFS 等）的介绍。

## 获取帮助

如果在完成作业过程中遇到困难，请利用课程提供的答疑渠道（助教）。

祝你探索分形之旅愉快！
