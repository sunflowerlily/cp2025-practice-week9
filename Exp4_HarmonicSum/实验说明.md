# 实验四：调和级数求和顺序与舍入误差

## 实验背景

在数学上，有限和的求和顺序不影响最终结果。例如，考虑调和级数的部分和：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} = 1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{N} $$

无论是从 $n=1$ 加到 $N$（称为 $S^{(up)}$），还是从 $n=N$ 加回到 $1$（称为 $S^{(down)}$），理论上结果应该完全相同：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} \quad \overset{\text{math}}{=} \quad S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} $$

然而，在计算机上使用有限精度浮点数进行计算时，会引入**舍入误差**。每次浮点运算（特别是加法）都可能丢失精度。当我们将一个非常小的数加到一个非常大的数上时，这种精度损失尤其显著，因为小数部分可能无法在有限的尾数位中表示出来。

本实验旨在探究求和顺序对舍入误差累积的影响，并理解为什么 $S^{(down)}$ 通常比 $S^{(up)}$ 更精确。

## 实验目标

1.  **实现两种求和顺序：** 编写代码计算 $S^{(up)}$ 和 $S^{(down)}$。
2.  **量化差异：** 计算并可视化两种方法结果之间的相对差异随 $N$ 的变化。
3.  **理解舍入误差累积：** 解释为什么从大项加到小项 ($S^{(up)}$) 会比从小项加到大项 ($S^{(down)}$) 积累更多的舍入误差。
4.  **实践性能工具 (可选)：** 使用 `time` 模块测量计算时间，并尝试使用 `numba.jit` 加速计算。

## 实验任务

1.  **实现求和函数：**
    *   在 `harmonic_sum.py` 文件中，完成 `sum_up(N)` 函数，计算 $S^{(up)}$。
    *   完成 `sum_down(N)` 函数，计算 $S^{(down)}$。

2.  **计算相对差异：**
    *   对于一系列 $N$ 值（例如，从 10 到 10000，建议在对数尺度上取点，如 `np.logspace(1, 4, 50)`），分别计算 $S^{(up)}$ 和 $S^{(down)}$。
    *   计算两者之间的相对差异 $\delta$。一个常用的定义是：

        $$\delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|}$$

        （注意处理分母可能为零的极端情况，尽管在此问题中 N>=1 时不会发生）。

3.  **绘制 Log-Log 图：**
    *   绘制相对差异 $\delta$ 关于 $N  的关系图，使用双对数坐标轴 (`plt.loglog`)。

4.  **分析与解释：**
    *   观察图表的趋势。相对差异是如何随 $N$ 变化的？
    *   解释为什么 $S^{(down)}$ 比 $S^{(up)}$ 更准确。考虑浮点数的表示方式：当 $S^{(up)}$ 的累加和变得很大时，再加上一个很小的 $1/N$ 项，会发生什么？相比之下, $S^{(down)}$ 先累加小的项，情况如何？

5.  **性能考量 (可选/练习)：**
    *   使用 `time.time()` 测量计算 $S^{(up)}$ 和 $S^{(down)}$ 对于一个较大的 $N$ (例如 $N=10^5$ 或 $10^6$) 所需的时间。
    *   尝试在你的求和函数前添加 `@jit(nopython=True)` 装饰器 (需要 `from numba import jit`)。再次测量时间（注意 Numba 第一次调用时有编译开销，测量第二次运行时间可能更具代表性）。比较 JIT 加速前后的性能。

## 代码模板

你需要在 `harmonic_sum.py` 文件中完成 `sum_up` 和 `sum_down` 函数。该文件包含一个 `if __name__ == '__main__':` 块，用于执行计算、打印结果和生成图表。

## 提交要求

1.  **代码：** 完成并提交 `harmonic_sum.py` 文件。
2.  **实验报告：** 提交一份Markdown 格式的实验报告 (`R实验报告.md`)，包含：
    *   **方法简述：** 描述你实现的两种求和方法。
    *   **结果图表：** 包含相对差异 $\delta$ vs $N$ 的双对数图。
    *   **分析与讨论：**
        *   解释图表的趋势。
        *   详细解释 $S^{(down)}$ 更精确的原因，结合浮点数舍入误差进行说明。
        *   如果做了性能测试，展示时间测量结果并讨论 Numba JIT 的效果。
    *   **结论：** 总结求和顺序对数值精度的影响。

## 评分标准

*   **代码实现 (40%)：**
    *   `sum_up` 函数正确实现 (20%)
    *   `sum_down` 函数正确实现 (20%)
*   **数据分析与可视化 (30%)：**
    *   相对差异计算正确 (10%)
    *   Log-log 图绘制正确、清晰，包含必要标签和图例 (20%)
*   **实验报告 (30%)：**
    *   对舍入误差和求和顺序影响的解释清晰、准确 (15%)
    *   图表分析到位 (10%)
    *   报告结构清晰，包含所有要求的部分 (5%)
    *   (可选的性能分析部分可酌情加分)