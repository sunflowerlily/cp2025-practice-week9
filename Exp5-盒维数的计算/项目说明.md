# 项目 5: 分形分析 - 盒计数法估算分形维数

### 目标

理解分形维数（特别是盒维数）的概念，并编程实现盒计数 (Box Counting) 算法，用以估算一个给定分形图像的维数。

### 背景

分形维数是衡量分形对象复杂性或其填充空间能力的一个指标，它通常不是一个整数。盒维数 (Box Dimension) 是计算分形维数的一种常用方法。

1.  **基本思想:** 用边长为 $\epsilon$ 的“盒子”（在 2D 图像上就是正方形）来覆盖分形集合。计算完全覆盖该集合所需的最小盒子数量 $N(\epsilon)$。
2.  **尺度关系:** 对于理想的分形，当盒子尺寸 $\epsilon$ 趋向于 0 时， $N(\epsilon)$ 与 $\epsilon$ 之间存在幂律关系：

$$ N(\epsilon) \propto \epsilon^{-D} $$

其中 $D$ 就是盒维数。
3.  **估算方法:** 为了从实际数据中估算 $D$，我们对上述关系两边取对数：

$$ \log N(\epsilon) \approx -D \log \epsilon + \text{constant} $$

这意味着，如果在对数-对数坐标系 (log-log plot) 中绘制 $N(\epsilon)$ 对 $\epsilon$ 的关系，这些点应该近似地落在一条直线上，并且这条直线的斜率是 $-D$。
4.  **算法流程:** 通过选择一系列不同的盒子尺寸 $\epsilon_1, \epsilon_2, \dots, \epsilon_k$，计算出对应的盒子数量 $N(\epsilon_1), N(\epsilon_2), \dots, N(\epsilon_k)$。然后，对数据点 $(\log \epsilon_i, \log N(\epsilon_i))$ 进行线性回归，拟合出最佳直线。该直线的斜率的相反数就是对盒维数 $D$ 的估算。

### 任务

1.  **准备输入图像:**
    *   选择一个你之前项目生成的、具有清晰分形结构的图像文件（例如，项目 3 的巴恩斯利蕨点云图, 在images/）。
    *   使用 Python 库（如 `PIL/Pillow` 或 `matplotlib.image`）读取该图像。
    *   将图像转换为 **二值图像 (Binary Image)**。这意味着图像应该只有两种颜色：背景色（例如黑色或白色，代表 0）和前景色（代表分形本身，例如白色或黑色，代表 1）。你可以通过设定一个阈值来实现这一点：像素值高于（或低于）阈值的设为 1，其他的设为 0。将处理后的二值图像存储为一个 NumPy 数组。

2.  **实现盒计数算法:**
    *   编写一个函数 `box_count(binary_image, box_sizes)`。
    *   `binary_image`: 输入的 NumPy 二值数组。
    *   `box_sizes`: 一个包含要测试的盒子边长 $\epsilon$ 的列表或数组。选择一系列 $\epsilon$ 值，通常是图像尺寸的幂次分割，例如 `[image_width // 2, image_width // 4, image_width // 8, ..., 2, 1]`。确保 $\epsilon$ 是整数。
    *   对于列表中的每一个 `epsilon`：
        *   计算需要多少个 `epsilon x epsilon` 的盒子来覆盖整个图像。
        *   遍历这些盒子（可以想象在图像上叠加一个网格）。
        *   对于每个盒子，检查它是否包含**至少一个**前景像素（值为 1）。
        *   统计包含前景像素的盒子数量，这就是 $N(\epsilon)$。
    *   函数返回一个列表或字典，存储每个 `epsilon` 对应的 $N(\epsilon)$。

3.  **数据处理与线性回归:**
    *   获取 `box_count` 函数返回的 `epsilon` 和 `N(epsilon)` 数据对。
    *   计算它们的对数：`log_eps = np.log(epsilons)` 和 `log_N = np.log(N_epsilons)`。
    *   使用 `numpy.polyfit(log_eps, log_N, 1)` 进行一阶多项式拟合（线性回归）。这将返回拟合直线的 `[斜率, 截距]`。

4.  **计算并报告维数:**
    *   从 `polyfit` 的结果中提取斜率 `slope`。
    *   估算的盒维数 $D = -\text{slope}$。
    *   在程序输出或代码注释中清晰地报告：
        *   所使用的 `epsilon` 值及其对应的 $N(\epsilon)$ 值（或它们的对数值）。
        *   线性拟合得到的斜率。
        *   最终估算的盒维数 $D$。

5.  **(可选) 可视化:**
    *   使用 `matplotlib.pyplot` 绘制 `log N(ε)` 对 `log ε` 的散点图。
    *   在同一图上绘制由 `polyfit` 得到的拟合直线。
    *   保存该图为 `log_log_plot.png`。这有助于直观判断线性拟合的好坏。

### 挑战与思考

*   **与理论值比较:** 对于某些标准分形（如科赫曲线的理论维数是 $\log 4 / \log 3 \approx 1.26$，谢尔宾斯基三角是 $\log 3 / \log 2 \approx 1.58$），将你的计算结果与理论值进行比较。
*   **误差分析:** 思考哪些因素可能导致计算结果与理论值存在偏差？（例如：图像分辨率有限、盒子尺寸的选择范围、图像边界处理、算法实现的精度等）。
*   **简单形状验证:** 尝试将你的盒计数算法应用于简单的非分形形状，如一条直线（理论维数 D=1）或一个实心正方形（理论维数 D=2）。你的算法是否能给出接近这些理论值的结果？

### 提交

*   `box_counting.py`: 包含图像加载、二值化、盒计数算法实现、线性回归和维数计算的完整 Python 代码。
*   在代码的注释或输出中，明确说明你使用了哪个分形图像进行分析，并报告计算过程中的关键数据（如 `(ε, N(ε))` 对或 `(log ε, log N(ε))` 对）以及最终估算的盒维数 `D`。
*   (可选) `log_log_plot.png`: 展示 `log N(ε)` vs `log ε` 散点图和拟合直线的图像文件。
